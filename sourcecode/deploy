#!/usr/bin/env ruby

# dependencies

require 'rubygems'
require 'bundler/setup'
require 'commander/import'
require 'random-word' # used for vm name generation
require 'fileutils'   # used for recursive folder creation
require 'dotenv'      # reading .env files
require 'bcrypt'

require 'slugify'
require "ipaddr"      # used for incrementing ip addresses
require "open3"       # used for vm password generation
require 'socket'      # used for netmasks
require 'resolv'      # use to check if generated ip is valid

require_relative 'lib/person'
require_relative 'lib/vm'

# load .env file
Dotenv.load

helper = Helper::Person.new(ENV)

program :name, 'deploy'
program :version, '0.0.1'
program :description, 'Create and destroy virtual machines'

# used for authentication of the user
global_option '--auth_user STRING',String, 'Specifies the authenticated user'
global_option '--auth_password STRING',String, 'Specifies the authenticated user\'s password'
global_option '--auth_token STRING', String, 'Instead of using user/password, use token instead'

command :list do |c|
  c.syntax = 'deploy list [options]'
  c.summary = 'List virtual machines associated with a user'
  c.description = 'List virtual machines associated with a user'
  c.example "Example", ""

  # used for authentication of the user

  c.action do |args, options|

    helper.valid_args!(options)

    # validate user credentials

    helper.authenticate!(options)
    helper.fetch_machines()
    
    helper.machines.each do |machine|
      $stdout.printf "#{machine.title} \t"
    end

    # adds newline for formatting
    $stdout.puts ""
  end
end

command :destroy do |c|
  c.syntax = 'deploy destroy [options]'
  c.summary = 'Removes a virtual machine'
  c.description = 'Removes a virtual machine'
  c.example "Example", ""

  # options for the actual virtual machine credentials, e.g. adduser foo with password bar
  c.option '--vm_name STRING',String, 'The name of the machine, generates a random name if left blank'
  c.action do |args, options|


    # enforce required arguments

    helper.valid_args!({
      'vm_name' => options.vm_name
    }, options)

    # validate user credentials

    helper.authenticate!(options)

    vm_directory = [Dir.pwd, "userspace",helper.user.email, options.vm_name].join('/')

    # machine = Helper::Machine.where(title: options.vm_name, user_id: helper.user.id).take
    machine = helper.get_machine(options.vm_name)

    if ! machine
      $stderr.puts "No virtual machine found with name '#{options.vm_name}'"
    end

    if Dir.exists?(vm_directory)
      Dir.chdir("#{vm_directory}") do
        result = system(
          "vagrant destroy -f"
        )

      end

      FileUtils.rm_rf("#{vm_directory}")
    end
    if machine
      machine.destroy
    end

  end
end

command :new do |c|
  c.syntax = 'deploy new [options]'
  c.summary = 'Creates a new virtual machine'
  c.description = 'Deploys a new virtual machine, sets up user and allocates public ip'
  c.example "Example", "deploy new --auth_user local@host.com --auth_password password --vm_user plamen --vm_password password --distribution ubuntu"

  # used for authentication of the user

  # options for the actual virtual machine credentials, e.g. adduser foo with password bar
  c.option '--vm_user STRING',        String, "Username of the machine"
  c.option '--vm_password STRING',    String, "Password of the machine"

  c.option '--distribution STRING',   String, 'The distribution flavour (ubuntu, debian, etc.)'
  c.option '--vm_name STRING',        String, 'The name of the machine, generates a random name if left blank'

  c.action do |args, options|

    # VARS

    options.default :vm_name => "#{RandomWord.adjs.next} #{RandomWord.adjs.next} #{RandomWord.nouns.next}"
    options.vm_name = options.vm_name.slugify

    helper.valid_args!({
      'vm_user' => options.vm_user, 
      'vm_password' => options.vm_password,
      'distribution' => options.distribution
    }, options)

    helper.authenticate!(options)
    machine = Helper::VM.new(distribution: options.distribution, name: options.vm_name, owner: helper, user: options.vm_user, password: options.vm_password)

    
    # validate vmname not taken

    if machine.in_db?
      $stderr.puts "Name #{options.vm_name} taken.We require unique names for each virtual machine, please use --vm_name and specify name"
      exit 1
    end

    # validate folder empty

    if machine.in_dir?
      $stderr.puts "Folder #{machine.root} contains a virtual machine, aborting"
      exit 1      
    end

    $stdout.puts "Using address #{machine.ip}"
    
    if machine.build()
      exit 0
    else
      exit 1
    end

  end
end