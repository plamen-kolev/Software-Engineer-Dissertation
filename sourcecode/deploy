#!/usr/bin/env ruby

# dependencies

require 'rubygems'
require 'commander/import'
require 'random-word' # used for vm name generation
require 'fileutils' # used for recursive folder creation
require 'dotenv' # reading .env files
require 'bcrypt'
require 'active_record'
require 'slugify'
require 'faker'
require "ipaddr" # used for incrementing ip addresses


# load .env file
Dotenv.load

# Allowed distributions
$distributions = {
  'ubuntu' => 'ubuntu/xenial64',
  'debian' => 'debian/jessie64'
}

$webserver_root = [Dir.pwd, 'deepsky'].join('/')

ActiveRecord::Base.establish_connection(
  adapter:  ENV['DATABASE_ADAPTER'], # or 'postgresql' or 'sqlite3' or 'oracle_enhanced'
  database: [$webserver_root,'db','development.sqlite3'].join('/'),
)

class User < ActiveRecord::Base
end

class Machine < ActiveRecord::Base
end

program :name, 'deploy'
program :version, '0.0.1'
program :description, 'Create and destroy virtual machines'

command :new do |c|
  c.syntax = 'deploy new [options]'
  c.summary = 'Creates a new virtual machine'
  c.description = ''
  c.example 'description', 'command example'

  # used for authentication of the user

  c.option '--auth_user STRING',String, 'Specifies the authenticated user'
  c.option '--auth_password STRING',String, 'Specifies the authenticated user\'s password'

  # options for the actual virtual machine credentials, e.g. adduser foo with password bar
  c.option '--vm_user', String, "Username of the machine"
  c.option '--vm_password', String "Password of the machine"

  c.option '--distribution STRING',String, 'The distribution flavour (ubuntu, debian, etc.)'
  c.option '--vm_name STRING',String, 'The name of the machine, generates a random name if left blank'
  c.action do |args, options|

    # VARS

    options.default :vm_name => "#{RandomWord.adjs.next} #{RandomWord.adjs.next} #{RandomWord.nouns.next}"
    options.vm_name = options.vm_name.slugify

    distribution = $distributions[options.distribution.to_s]
    vm_directory = ["userspace",options.auth_user, options.vm_name].join('/')
    # enforce required arguments

    {'vm_user' => options.vm_user, 'vm_password' => options.vm_password,'auth_user' => options.auth_user, 'auth_password' => options.auth_password, 'distribution' => options.distribution}.each do |key, value|
      if value.to_s.empty?
        $stderr.puts "Missing argument: --#{key},\nuse --help for detailed instructions"
        exit 1
      end
    end
    
    # validate that the username exists

    db_user = User.where(email: options.auth_user).take

    if (not db_user) or db_user.email != options.auth_user
      $stderr.puts "Unable to find user '#{options.auth_user}' in the system"
      exit 1
    end

    # validate password match

    bcrypt   = ::BCrypt::Password.new(db_user.encrypted_auth_password)
    password = ::BCrypt::Engine.hash_secret(options.auth_password, bcrypt.salt)

    if password != db_user.encrypted_password
      $stderr.puts "Username or password incorrect"
      exit 1
    end

    # validate that distribution is allowed
    
    if ! distribution
      $stderr.puts "Distribution '#{options.distribution.to_s}' is not a recognized option,\nOptions are: #{$distributions.keys}, aborting"
      exit 1
    end

    # validate vmname not taken

    machine = Machine.where(title: options.vm_name).take
    if machine
      $stderr.puts "Name #{options.vm_name} taken.We require unique names for each virtual machine, please use --vm_name and specify name"
      exit 1
    end

    # validate folder not taken

    if File.directory?(vm_directory)
      $stderr.puts "Folder #{vm_directory} contains a virtual machine, aborting"
      exit 1      
    end

    # generate public ip
    ips = Machine.all.collect { |obj| obj.ip }
    new_ip = generate_ip(ips)

    vagrant_conf = <<HERE
    Vagrant.configure(2) do |config|
      config.vm.box = "#{distribution}"
      config.vm.network "public_network", ip: "#{new_ip}"
      config.vm.provider "virtualbox" do |vb|
        vb.customize ["modifyvm", :id, "--cableconnected1", "on"]
         vb.name = "#{options.vm_name}"
      end
    end
HERE
    
    if Dir.exists?(vm_directory)
      $stderr.puts "Directory #{vm_directory} exists, aborting"
      exit 1
    else
      FileUtils.mkdir_p(vm_directory)
    end
    
    # puts vagrant_conf

    # write conf file
    File.open("#{vm_directory}/Vagrantfile", 'w') { |file| 
      file.write(vagrant_conf)
    }
    
    # build machine
    new_machine = Machine.create(title: options.vm_name, user_id: db_user.id, ip: new_ip, deployed: false)
    result = system(
      {
        "VAGRANT_DOTFILE_PATH" => "#{vm_directory}/",
        "VAGRANT_VAGRANTFILE" => "#{vm_directory}/Vagrantfile",
      },
      "/usr/bin/vagrant up"
    )

    puts result.inspect
    if result
      $stdout.puts("Virtual machine '#{options.vm_name}' created successfully for user '#{options.auth_user}' using distribution '#{distribution}'") 
      new_machine.deployed=true
      new_machine.save
      exit 0
    else
      $stderr.puts("Errors were encountered: #{$?.inspect}")
    end

  end
end

def generate_ip(ips)
  ips.sort! { |a,b| compare_ips(a,b) }
  # grap the last ip from the array
  last = ips[-1]
  addr = IPAddr.new(last)
  begin
    return addr.succ.to_s
  rescue IPAddr::InvalidAddressError
    $stderr.puts("Ip range exhausted")
    exit 1
  end
end

def compare_ips(first, second)
  ip1 = first.split('.').map(&:to_i)
  ip2 = second.split('.').map(&:to_i)
  raise if ip1.size != ip2.size
  for i in 0..ip1.size-1 do
    if ip1[i] != ip2[i]
      return ip1[i] <=> ip2[i]
    end
  end
  return 0
end

